{"meta":{"title":"Hexo","subtitle":null,"description":null,"author":"John Doe","url":"https://Sjiay1023.github.io","root":"/"},"pages":[{"title":"404 Not Found：该页无法显示","date":"2019-08-20T08:04:03.299Z","updated":"2019-08-19T11:30:40.838Z","comments":false,"path":"/404.html","permalink":"https://Sjiay1023.github.io//404.html","excerpt":"","text":""},{"title":"书单","date":"2019-08-20T03:01:43.184Z","updated":"2019-08-19T11:30:40.842Z","comments":false,"path":"books/index.html","permalink":"https://Sjiay1023.github.io/books/index.html","excerpt":"","text":""},{"title":"关于","date":"2019-08-20T08:04:06.398Z","updated":"2019-08-19T11:30:40.840Z","comments":false,"path":"about/index.html","permalink":"https://Sjiay1023.github.io/about/index.html","excerpt":"","text":"个人详细介绍"},{"title":"友情链接","date":"2019-08-20T03:09:21.236Z","updated":"2019-08-19T11:30:40.843Z","comments":true,"path":"links/index.html","permalink":"https://Sjiay1023.github.io/links/index.html","excerpt":"","text":""},{"title":"分类","date":"2019-08-20T08:00:39.670Z","updated":"2019-08-19T11:30:40.842Z","comments":false,"path":"categories/index.html","permalink":"https://Sjiay1023.github.io/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"2019-08-20T08:00:39.653Z","updated":"2019-08-19T11:30:40.844Z","comments":false,"path":"tags/index.html","permalink":"https://Sjiay1023.github.io/tags/index.html","excerpt":"","text":""},{"title":"Repositories","date":"2019-08-20T08:05:31.077Z","updated":"2019-08-19T11:30:40.844Z","comments":false,"path":"repository/index.html","permalink":"https://Sjiay1023.github.io/repository/index.html","excerpt":"","text":""}],"posts":[{"title":"SpringBoot整合SpringSecurity+jwt+redis实现登录鉴权","slug":"SpringBoot整合SpringSecurity+jwt+redis实现登录鉴权","date":"2019-09-18T08:35:22.000Z","updated":"2019-09-20T08:16:15.601Z","comments":true,"path":"2019/09/18/SpringBoot整合SpringSecurity+jwt+redis实现登录鉴权/","link":"","permalink":"https://Sjiay1023.github.io/2019/09/18/SpringBoot整合SpringSecurity+jwt+redis实现登录鉴权/","excerpt":"本项目是SpringBoot+Mybatis实现的后端项目,相关测试都使用postman进行了测试，主要的思想是利用token作为前后端交互身份验证信息，通过设置token的刷新时间来保证token的安全性，同时将token放入redis中，并建立黑名单，将过期以及登出的token移到黑名单，使用SpringSecurity实现对用户的认证鉴权。","text":"本项目是SpringBoot+Mybatis实现的后端项目,相关测试都使用postman进行了测试，主要的思想是利用token作为前后端交互身份验证信息，通过设置token的刷新时间来保证token的安全性，同时将token放入redis中，并建立黑名单，将过期以及登出的token移到黑名单，使用SpringSecurity实现对用户的认证鉴权。 #主要环境编译器使用Idea，项目使用SpringBoot+Maven进行构建，SpringSecurity进行认证和授权，其中还涉及到的框架包括Mybatis、Redis、Druid、JWT、Lombok、Logback。其中Redis的安装以及Idea中集成Lombok等插件不单独进行展开，可自行百度进行环境准备。[github项目地址] (https://github.com/Sjiay1023/permission) #系统机构图 一、SpringBoot##创建项目我是使用IDEA创建项目，jdk选择1.8选择maven构建，相关名字自行命名添加依赖，后面redis，sercurity等依赖后续再加，我这边使用的SpringBoot版本是2.1.2.RELEASE，注意改成你自己想要的SpringBoot版本ok，最简单的一个SpringBoot项目就搭建完成 此处直接将后面需要用到的依赖全部一并给出，分别为lombok、redis、fastjson、jwt、druid,Security的依赖这边暂时没有加上，到后面再加防止获取用户列表报错具体pom文件如下： 123456789101112131415161718192021222324&lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;version&gt;1.18.8&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;fastjson&lt;/artifactId&gt; &lt;version&gt;1.2.46&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;io.jsonwebtoken&lt;/groupId&gt; &lt;artifactId&gt;jjwt&lt;/artifactId&gt; &lt;version&gt;0.9.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;version&gt;1.1.10&lt;/version&gt; &lt;/dependency&gt; ##配置application.yml包括了数据源、Mybatis、redis、druid等的完整配置 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849server: servlet: context-path: /permission port: 8080spring: jackson: date-format: yyyy-MM-dd HH:mm:ss time-zone: GMT application: name: permission datasource: driver-class-name: com.mysql.cj.jdbc.Driver url: jdbc:mysql://127.0.0.1:3306/ssm?useUnicode=true&amp;characterEncoding=utf8&amp;serverTimezone=UTC username: root password: root druid: initial-size: 3 min-idle: 3 max-active: 10 max-wait: 60000 stat-view-servlet: login-username: admin login-password: admin filter: stat: log-slow-sql: true slow-sql-millis: 2000 redis: database: 0 host: 192.168.46.128 port: 6379 password: 123456mybatis: type-aliases-package: com.sjiay.security.permission.entity mapper-locations: classpath*:/mapper/**/*Mapper.xml configuration: map-underscore-to-camel-case: true use-generated-keys: true default-fetch-size: 100 default-statement-timeout: 30#自定义参数，可以迁移走token: #token失效时间（不是refreshToken）(这是自定义的)(秒) expirationSeconds: 300 #默认7天登录有效(根据业务更改) validTime: 7 context-path路径的设置时为了后续对Url的统一拦截，注意SpringBoot2.0之后把server.context-path改成了server.servlet.context-path,这个根据自己版本修改。 二、简单Demo实现相关配置完成之后，我们就来先实现一个简单的Demo主要功能就是查询数据库User列表，以及一个简单的注册 ##controller层 123456789101112131415161718192021222324252627282930313233343536373839404142package com.sjiay.permission.controller;import com.sjiay.permission.entity.DemoEntity;import com.sjiay.permission.service.DemoService;import com.sjiay.common.Enums.ResultEnum;import com.sjiay.common.VO.ResultVO;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.web.bind.annotation.PostMapping;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController;import java.util.List;import java.util.Map;@RestController@RequestMapping(&quot;/test&quot;)public class DemoController &#123; @Autowired private DemoService demoService; /** * 获取User列表 * @return */ @RequestMapping(&quot;/getUser&quot;) public List&lt;DemoEntity&gt; getUser()&#123; List&lt;DemoEntity&gt; result = demoService.getUser(); return result; &#125; /** * 简单注册功能 * @param username * @param password * @return */ @PostMapping(&quot;/register&quot;) public Map&lt;String, Object&gt; register(String username, String password)&#123; demoService.register(username,password); return ResultVO.result(ResultEnum.SUCCESS,true); &#125;&#125; 看到上面controller的返回结果是做了一些封装，所以这边我们穿插一下先来实现几个返回格式的类。 ##返回格式封装为了整个项目结构清晰，把一些公用的以及后面涉及的拦截相关的类我们单独放到一个包里面，在 permission(新建项目时候的最底层包名)的同级目录下新建一个common包，具体common下又分成很多子包，具体看后面类的package 所指目录，或到源码下查看。两个类如下：ResultVO 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134package com.sjiay.common.VO;import com.sjiay.common.Enums.ResultEnum;import java.io.Serializable;import java.util.HashMap;import java.util.Map;/** * @description: 返回的格式 */public final class ResultVO implements Serializable &#123; private static final long serialVersionUID = 1725159680599612404L; /** * 返回msg，object，以及token * 返回的code为默认 * @param message * @param data * @param jwtToken * @return */ public final static Map&lt;String, Object&gt; success(String message, Object data,String jwtToken,Boolean success) &#123; Map&lt;String, Object&gt; map = new HashMap&lt;&gt;(); map.put(&quot;jwtToken&quot;,jwtToken); map.put(&quot;code&quot;, ResultEnum.SUCCESS.getCode()); map.put(&quot;message&quot;, message); map.put(&quot;success&quot;,success); map.put(&quot;data&quot;, data); return map; &#125; /** * 返回object，以及token * 返回的msg，code为默认 * @param data * @param jwtToken * @return */ public final static Map&lt;String, Object&gt; success(Object data,String jwtToken) &#123; Map&lt;String, Object&gt; map = new HashMap&lt;String, Object&gt;(); map.put(&quot;jwtToken&quot;,jwtToken); map.put(&quot;code&quot;, ResultEnum.SUCCESS.getCode()); map.put(&quot;message&quot;, ResultEnum.SUCCESS.getMessage()); map.put(&quot;data&quot;, data); map.put(&quot;success&quot;,true); return map; &#125; /** * 返回默认的信息 * @return */ public final static Map&lt;String, Object&gt; success() &#123; Map&lt;String, Object&gt; map = new HashMap&lt;String, Object&gt;(); map.put(&quot;jwtToken&quot;,null); map.put(&quot;code&quot;, ResultEnum.SUCCESS.getCode()); map.put(&quot;message&quot;, ResultEnum.SUCCESS.getMessage()); map.put(&quot;data&quot;, null); map.put(&quot;success&quot;,true); return map; &#125; public final static Map&lt;String, Object&gt; failure(int code, String message,Object data) &#123; Map&lt;String, Object&gt; map = new HashMap&lt;String, Object&gt;(); map.put(&quot;code&quot;, code); map.put(&quot;message&quot;, message); map.put(&quot;data&quot;, data); map.put(&quot;success&quot;,false); return map; &#125; public final static Map&lt;String, Object&gt; failure(int code, String message) &#123; Map&lt;String, Object&gt; map = new HashMap&lt;String, Object&gt;(); map.put(&quot;code&quot;, code); map.put(&quot;message&quot;, message); map.put(&quot;data&quot;, null); map.put(&quot;success&quot;,false); return map; &#125; public final static Map&lt;String, Object&gt; failure(ResultEnum respCode, Object data, Boolean success) &#123; return getStringObjectMap(respCode, data,success); &#125; public final static Map&lt;String, Object&gt; failure(ResultEnum respCode, Boolean success) &#123; return getStringObjectMap(respCode,success); &#125; /* * 成功返回特定的状态码和信息 * */ public final static Map&lt;String, Object&gt; result(ResultEnum respCode, Object data, Boolean success) &#123; return getStringObjectMap(respCode, data,success); &#125; private static Map&lt;String, Object&gt; getStringObjectMap(ResultEnum respCode, Object data, Boolean success) &#123; Map&lt;String, Object&gt; map = new HashMap&lt;String, Object&gt;(); map.put(&quot;code&quot;, respCode.getCode()); map.put(&quot;message&quot;, respCode.getMessage()); map.put(&quot;data&quot;, data); map.put(&quot;success&quot;,success); return map; &#125; /* * 成功返回特定的状态码和信息 * */ public final static Map&lt;String, Object&gt; result(ResultEnum respCode, Boolean success) &#123; return getStringObjectMap(respCode,success); &#125; private static Map&lt;String, Object&gt; getStringObjectMap(ResultEnum respCode, Boolean success) &#123; Map&lt;String, Object&gt; map = new HashMap&lt;String, Object&gt;(); map.put(&quot;code&quot;, respCode.getCode()); map.put(&quot;message&quot;, respCode.getMessage()); map.put(&quot;data&quot;, null); map.put(&quot;success&quot;,success); return map; &#125; /* * 成功返回特定的状态码和信息 * */ public final static Map&lt;String, Object&gt; result(ResultEnum respCode, String jwtToken, Boolean success) &#123; Map&lt;String, Object&gt; map = new HashMap&lt;String, Object&gt;(); map.put(&quot;jwtToken&quot;,jwtToken); map.put(&quot;code&quot;, respCode.getCode()); map.put(&quot;message&quot;, respCode.getMessage()); map.put(&quot;data&quot;, null); map.put(&quot;success&quot;,success); return map; &#125;&#125; 这边考虑到了多种情况下的返回格式，运用了多态，其中jwtToken的返回在后面Token鉴权中会有用到，这边就先这么写了，code，message用ResultEnum枚举类封装如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445package com.sjiay.common.Enums;public enum ResultEnum &#123; SUCCESS(101,&quot;成功&quot;), FAILURE(102,&quot;失败&quot;), USER_NEED_AUTHORITIES(201,&quot;用户未登录&quot;), USER_LOGIN_FAILED(202,&quot;用户账号或密码错误&quot;), USER_LOGIN_SUCCESS(203,&quot;用户登录成功&quot;), USER_NO_ACCESS(204,&quot;用户无权访问&quot;), USER_LOGOUT_SUCCESS(205,&quot;用户登出成功&quot;), TOKEN_IS_BLACKLIST(206,&quot;此token为黑名单&quot;), LOGIN_IS_OVERDUE(207,&quot;登录已失效&quot;), ; private Integer code; private String message; ResultEnum(Integer code, String message) &#123; this.code = code; this.message = message; &#125; public Integer getCode() &#123; return code; &#125; public String getMessage() &#123; return message; &#125; /** * 通过code返回枚举 * @param code * @return */ public static ResultEnum parse(int code)&#123; ResultEnum[] values = values(); for (ResultEnum value : values) &#123; if(value.getCode() == code)&#123; return value; &#125; &#125; throw new RuntimeException(&quot;Unknown code of ResultEnum&quot;); &#125;&#125; ##service层接口： 12345678910package com.sjiay.permission.service;import com.sjiay.permission.entity.DemoEntity;import java.util.List;public interface DemoService &#123; List&lt;DemoEntity&gt; getUser(); void register(String username, String password);&#125; Impl: 123456789101112131415161718192021222324252627package com.sjiay.permission.service.impl;import com.sjiay.permission.entity.DemoEntity;import com.sjiay.permission.mapper.DemoMapper;import com.sjiay.permission.service.DemoService;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;import org.springframework.stereotype.Service;import java.util.List;@Servicepublic class DemoServiceImpl implements DemoService &#123; @Autowired private DemoMapper demoMapper; @Override public List&lt;DemoEntity&gt; getUser() &#123; return demoMapper.getUser(); &#125; @Override public void register(String username, String password) &#123; //因为只是简单注册，故只是对密码加密保存，其他就不添加进来了 //BCryptPasswordEncoder bCryptPasswordEncoder = new BCryptPasswordEncoder(); //String EncryptedPassword = bCryptPasswordEncoder.encode(password); demoMapper.register(username,password); &#125;&#125; ##mapper层 12345678910111213package com.sjiay.permission.mapper;import com.sjiay.permission.entity.DemoEntity;import org.apache.ibatis.annotations.Param;import org.springframework.stereotype.Repository;import java.util.List;@Repositorypublic interface DemoMapper &#123; List&lt;DemoEntity&gt; getUser(); void register(@Param(&quot;username&quot;) String username, @Param(&quot;password&quot;) String password);&#125; 对应的DemoMapper.xml: 12345678910111213141516&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot; &gt;&lt;mapper namespace=&quot;com.sjiay.permission.mapper.DemoMapper&quot;&gt; &lt;select id=&quot;getUser&quot; resultType=&quot;com.sjiay.permission.entity.DemoEntity&quot;&gt; SELECT * FROM girl &lt;/select&gt; &lt;insert id=&quot;register&quot; parameterType=&quot;String&quot;&gt; &lt;selectKey keyProperty=&quot;id&quot; order=&quot;AFTER&quot; resultType=&quot;java.lang.Long&quot;&gt; SELECT LAST_INSERT_ID() &lt;/selectKey&gt; insert into user (username, password) values (#&#123;username,jdbcType=VARCHAR&#125;, #&#123;password,jdbcType=VARCHAR&#125;) &lt;/insert&gt;&lt;/mapper&gt; ##entity 12345678910111213141516171819202122232425262728293031323334353637383940package com.sjiay.permission.entity;public class DemoEntity &#123; private Integer id; private Integer age; private String name; private Float feight; public Integer getId() &#123; return id; &#125; public void setId(Integer id) &#123; this.id = id; &#125; public Integer getAge() &#123; return age; &#125; public void setAge(Integer age) &#123; this.age = age; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public Float getFeight() &#123; return feight; &#125; public void setFeight(Float feight) &#123; this.feight = feight; &#125;&#125; 实体类中的get,set方法可以使用Lombok插件的@Data注解让其在编译时自动生成，这边还是写完整了，在实际项目中可以减少不少代码量，数据库中的主要有两个表，一个girl表和DemoEntity字段名一样就可以，另外一个user表主要有username和password就可以，具体脚本如下： 123456789101112131415161718192021222324DROP TABLE IF EXISTS `girl`;CREATE TABLE `girl` ( `id` int(11) NOT NULL AUTO_INCREMENT, `age` int(10) NULL DEFAULT NULL, `name` varchar(10) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL, `height` float(10, 2) NULL DEFAULT NULL, PRIMARY KEY (`id`) USING BTREE) ENGINE = InnoDB AUTO_INCREMENT = 3 CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Dynamic;SET FOREIGN_KEY_CHECKS = 1;DROP TABLE IF EXISTS `user`;CREATE TABLE `user` ( `id` int(11) NOT NULL AUTO_INCREMENT, `username` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT &apos;用户名&apos;, `password` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT &apos;密码&apos;, `sex` int(11) NULL DEFAULT NULL COMMENT &apos;性别（1=男；2=女）&apos;, `is_active` int(11) NULL DEFAULT 1 COMMENT &apos;是否有效（1=是；0=否）&apos;, `create_time` datetime(0) NULL DEFAULT CURRENT_TIMESTAMP COMMENT &apos;创建时间&apos;, `update_time` timestamp(0) NULL DEFAULT NULL ON UPDATE CURRENT_TIMESTAMP(0) COMMENT &apos;更新时间&apos;, PRIMARY KEY (`id`) USING BTREE, UNIQUE INDEX `idx_user_name`(`username`) USING BTREE) ENGINE = InnoDB AUTO_INCREMENT = 4 CHARACTER SET = utf8 COLLATE = utf8_general_ci COMMENT = &apos;用户信息表&apos; ROW_FORMAT = Dynamic;SET FOREIGN_KEY_CHECKS = 1; OK我们访问http://localhost:8080/permission/test/getUser看一下结果成功获取到结果，注册也成功完成，接下来我们在这基础上来引入SpringSercurity实现相应的拦截 三、SpringSecurity##引入相关依赖 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt; &lt;/dependency&gt; ##注册密码加密在进行用户注册时，我们使用了BCryptPasswordEncoder对密码进行了加密之后再进行入库，其中BCryptPasswordEncoder类是SpringSecurity类提供的的加密算法，主要使用BCrypt强哈希方法来加密密码，使每次加密的结果都不一样，具体加密实现没有深入研究，也可使用自定义加密算法来加密，只需修改DemoServiceImpl如下： 123456789101112131415161718192021222324252627package com.sjiay.permission.service.impl;import com.sjiay.permission.entity.DemoEntity;import com.sjiay.permission.mapper.DemoMapper;import com.sjiay.permission.service.DemoService;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;import org.springframework.stereotype.Service;import java.util.List;@Servicepublic class DemoServiceImpl implements DemoService &#123; @Autowired private DemoMapper demoMapper; @Override public List&lt;DemoEntity&gt; getUser() &#123; return demoMapper.getUser(); &#125; @Override public void register(String username, String password) &#123; //因为只是简单注册，故只是对密码加密保存，其他就不添加进来了 BCryptPasswordEncoder bCryptPasswordEncoder = new BCryptPasswordEncoder(); String EncryptedPassword = bCryptPasswordEncoder.encode(password); demoMapper.register(username,EncryptedPassword); &#125;&#125; ##实现SpringSecurity各个核心接口，处理用户各种状态 实现AuthenticationEntryPoint接口，处理用户未登录 12345678910111213141516171819202122package com.sjiay.common.security;import com.alibaba.fastjson.JSON;import com.sjiay.common.VO.ResultVO;import com.sjiay.common.Enums.ResultEnum;import org.springframework.security.core.AuthenticationException;import org.springframework.security.web.AuthenticationEntryPoint;import org.springframework.stereotype.Component;import javax.servlet.ServletException;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;@Componentpublic class AjaxAuthenticationEntryPoint implements AuthenticationEntryPoint &#123; @Override public void commence(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, AuthenticationException e) throws IOException, ServletException &#123; httpServletResponse.setCharacterEncoding(&quot;utf-8&quot;); httpServletResponse.getWriter().write(JSON.toJSONString(ResultVO.result(ResultEnum.USER_NEED_AUTHORITIES,false))); &#125;&#125; 实现AccessDeniedHandler接口，处理无权登录的情况 1234567891011121314151617181920212223package com.sjiay.common.security;import com.alibaba.fastjson.JSON;import com.sjiay.common.VO.ResultVO;import com.sjiay.common.Enums.ResultEnum;import org.springframework.security.access.AccessDeniedException;import org.springframework.security.web.access.AccessDeniedHandler;import org.springframework.stereotype.Component;import javax.servlet.ServletException;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;@Componentpublic class AjaxAccessDeniedHandler implements AccessDeniedHandler &#123; @Override public void handle(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, AccessDeniedException e) throws IOException, ServletException &#123; httpServletResponse.setCharacterEncoding(&quot;utf-8&quot;); httpServletResponse.getWriter().write(JSON.toJSONString(ResultVO.result(ResultEnum.USER_NO_ACCESS,false))); &#125;&#125; 实现AuthenticationFailureHandler接口，处理用户登录失败 12345678910111213141516171819202122package com.sjiay.common.security;import com.alibaba.fastjson.JSON;import com.sjiay.common.VO.ResultVO;import com.sjiay.common.Enums.ResultEnum;import org.springframework.security.core.AuthenticationException;import org.springframework.security.web.authentication.AuthenticationFailureHandler;import org.springframework.stereotype.Component;import javax.servlet.ServletException;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;@Componentpublic class AjaxAuthenticationFailureHandler implements AuthenticationFailureHandler &#123; @Override public void onAuthenticationFailure(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, AuthenticationException e) throws IOException, ServletException &#123; httpServletResponse.setCharacterEncoding(&quot;utf-8&quot;); httpServletResponse.getWriter().write(JSON.toJSONString(ResultVO.result(ResultEnum.USER_LOGIN_FAILED,false))); &#125;&#125; 实现AuthenticationSuccessHandler接口，处理登录成功的情况 12345678910111213141516171819202122232425package com.sjiay.common.security;import com.alibaba.fastjson.JSON;import com.deceen.common.Enums.ResultEnum;import com.deceen.common.VO.ResultVO;import org.springframework.security.core.Authentication;import org.springframework.security.web.authentication.AuthenticationSuccessHandler;import org.springframework.stereotype.Component; import javax.servlet.ServletException;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException; @Componentpublic class AjaxAuthenticationSuccessHandler implements AuthenticationSuccessHandler &#123; @Override public void onAuthenticationSuccess(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Authentication authentication) throws IOException, ServletException &#123; SelfUserDetails userDetails = (SelfUserDetails) authentication.getPrincipal(); String jwtToken = JwtTokenUtil.generateToken(userDetails.getUsername(), 1500); httpServletResponse.setCharacterEncoding(&quot;utf-8&quot;); httpServletResponse.getWriter().write(JSON.toJSONString(ResultVO.result(ResultEnum.USER_LOGIN_SUCCESS,jwtToken,true))); &#125;&#125; 这里使用JwtTokenUtil工具类生成token后面会有具体实现，这边就不展开了 实现LogoutSuccessHandler接口，处理退出成功 12345678910111213141516171819202122package com.sjiay.common.security; import com.alibaba.fastjson.JSON;import com.deceen.common.Enums.ResultEnum;import com.deceen.common.VO.ResultVO;import org.springframework.security.core.Authentication;import org.springframework.security.web.authentication.logout.LogoutSuccessHandler;import org.springframework.stereotype.Component; import javax.servlet.ServletException;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;@Componentpublic class AjaxLogoutSuccessHandler implements LogoutSuccessHandler &#123; @Override public void onLogoutSuccess(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Authentication authentication) throws IOException, ServletException &#123; httpServletResponse.setCharacterEncoding(&quot;utf-8&quot;); httpServletResponse.getWriter().write(JSON.toJSONString(ResultVO.result(ResultEnum.USER_LOGOUT_SUCCESS,true))); &#125;&#125; 实现UserDetails实现自定义对象 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677package com.sjiay.permission.entity;import org.springframework.security.core.GrantedAuthority;import org.springframework.security.core.userdetails.UserDetails;import java.io.Serializable;import java.util.Collection;import java.util.Set;/** * 定义user对象 */public class SelfUserDetails implements UserDetails, Serializable &#123; private static final long serialVersionUID = 7171722954972237961L; private Integer id; private String username; private String password; private Set&lt;? extends GrantedAuthority&gt; authorities; @Override public Collection&lt;? extends GrantedAuthority&gt; getAuthorities() &#123; return this.authorities; &#125; public void setAuthorities(Set&lt;? extends GrantedAuthority&gt; authorities) &#123; this.authorities = authorities; &#125; @Override public String getPassword() &#123;// 最重点Ⅰ return this.password; &#125; @Override public String getUsername() &#123;// 最重点Ⅱ return this.username; &#125; public void setUsername(String username) &#123; this.username = username; &#125; public void setPassword(String password) &#123; this.password = password; &#125; //账号是否过期 @Override public boolean isAccountNonExpired() &#123; return true; &#125; //账号是否锁定 @Override public boolean isAccountNonLocked() &#123; return true; &#125; //账号凭证是否未过期 @Override public boolean isCredentialsNonExpired() &#123; return true; &#125; @Override public boolean isEnabled() &#123; return true; &#125; public Integer getId() &#123; return id; &#125; public void setId(Integer id) &#123; this.id = id; &#125;&#125; ##权限访问控制 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849package com.sjiay.common.security;import org.springframework.security.core.Authentication;import org.springframework.security.core.userdetails.UserDetails;import org.springframework.stereotype.Component;import org.springframework.util.AntPathMatcher;import javax.servlet.http.HttpServletRequest;import java.util.HashSet;import java.util.Set;/** * @description: 权限访问控制 */@Component(&quot;rbacauthorityservice&quot;)public class RbacAuthorityService &#123; public boolean hasPermission(HttpServletRequest request, Authentication authentication) &#123; Object userInfo = authentication.getPrincipal(); boolean hasPermission = false; if (userInfo instanceof UserDetails) &#123; String username = ((UserDetails) userInfo).getUsername(); //获取资源 Set&lt;String&gt; urls = new HashSet(); // 这些 url 都是要登录后才能访问，且其他的 url 都不能访问！ //application.yml里设置的context-path urls.add(&quot;/permission/**&quot;); Set set2 = new HashSet(); Set set3 = new HashSet(); AntPathMatcher antPathMatcher = new AntPathMatcher(); for (String url : urls) &#123; if (antPathMatcher.match(url, request.getRequestURI())) &#123; hasPermission = true; break; &#125; &#125; return hasPermission; &#125; else &#123; return false; &#125; &#125;&#125; 注意这里的url记得改成application.yml里设置的context-path，用于整体性的路径控制 ##JWT生成Token的工具类相关依赖上面已经说过这边不在说明，实现工具类如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103package com.sjiay.common.utils;import io.jsonwebtoken.Claims;import io.jsonwebtoken.Jwts;import io.jsonwebtoken.SignatureAlgorithm;import org.springframework.beans.factory.annotation.Autowired;import java.io.InputStream;import java.security.KeyStore;import java.security.PrivateKey;import java.security.PublicKey;import java.util.Date;import java.util.Map;/** * @description: jwt生成token */public class JwtTokenUtil &#123; @Autowired private static RedisUtil redisUtil; // 寻找证书文件 private static InputStream inputStream = Thread.currentThread().getContextClassLoader().getResourceAsStream(&quot;jwt.jks&quot;); // 寻找证书文件 private static PrivateKey privateKey = null; private static PublicKey publicKey = null; static &#123; // 将证书文件里边的私钥公钥拿出来 try &#123; KeyStore keyStore = KeyStore.getInstance(&quot;JKS&quot;); // java key store 固定常量 keyStore.load(inputStream, &quot;123456&quot;.toCharArray()); privateKey = (PrivateKey) keyStore.getKey(&quot;jwt&quot;, &quot;123456&quot;.toCharArray()); // jwt 为 命令生成整数文件时的别名 publicKey = keyStore.getCertificate(&quot;jwt&quot;).getPublicKey(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; /** * 生成token * @param subject （主体信息） * @param expirationSeconds 过期时间（秒） * @return */ public static String generateToken(String subject, int expirationSeconds,Map&lt;String,Object&gt; claims) &#123; return Jwts.builder() .setClaims(claims) .setSubject(subject) .setExpiration(new Date(System.currentTimeMillis() + expirationSeconds * 1000))// .signWith(SignatureAlgorithm.HS512, salt) // 不使用公钥私钥 .signWith(SignatureAlgorithm.RS256, privateKey) .compact(); &#125; /** * @author: zzx * @date: 2018-10-19 09:10 * @deprecation: 解析token,获得subject中的信息 */ public static String parseToken(String token, String salt) &#123; String subject = null; try &#123; /*Claims claims = Jwts.parser()// .setSigningKey(salt) // 不使用公钥私钥 .setSigningKey(publicKey) .parseClaimsJws(token).getBody();*/ subject = getTokenBody(token).getSubject(); &#125; catch (Exception e) &#123; &#125; return subject; &#125; //获取token自定义属性 public static Map&lt;String,Object&gt; getClaims(String token)&#123; Map&lt;String,Object&gt; claims = null; try &#123; claims = getTokenBody(token); &#125;catch (Exception e) &#123; &#125; return claims; &#125; // 是否已过期 public static boolean isExpiration(String expirationTime)&#123; //return getTokenBody(token).getExpiration().before(new Date()); //通过redis中的失效时间进行判断 String currentTime = DateUtil.getTime(); if(DateUtil.compareDate(currentTime,expirationTime))&#123; //当前时间比过期时间小，失效 return true; &#125;else&#123; return false; &#125; &#125; private static Claims getTokenBody(String token)&#123; return Jwts.parser() .setSigningKey(publicKey) .parseClaimsJws(token) .getBody(); &#125;&#125; 文中的jwt.jks是jwt证书，你可以自己生成，也可以用我生产好的在github项目中的resource目录下找这边简单说一下思路：每次登陆成功会返回token给前端做本地保存，以后每一次前端请求api都会在请求头中带上这个token，我们后面加入一个过滤器，专门拦截token然后验证。针对token暴露的问题，是实现一个黑名单，每一次登出或失效的token都加入黑名单（这一块我用redis实现，用其他缓存数据库都行，就是一个思路的问题）。token生成的时候也会在redis加入相应刷新时间和失效时间（例如：7天免登陆，即在7天内会自动刷新用户的token；而失效时间定为十五分钟，即每个token只有15分钟有效时间，过了这个时间，会去判断是否在刷新时间内，如果是，则refresh token，并set进request的请求头之中） ##jwt拦截器 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950package com.sjiay.common.filters; import com.deceen.common.utils.JwtTokenUtil;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;import org.springframework.security.core.context.SecurityContextHolder;import org.springframework.security.core.userdetails.UserDetails;import org.springframework.security.web.authentication.WebAuthenticationDetailsSource;import org.springframework.stereotype.Component;import org.springframework.web.filter.OncePerRequestFilter; import javax.servlet.FilterChain;import javax.servlet.ServletException;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException; /** * @description: 确保在一次请求只通过一次filter，而不需要重复执行 */@Componentpublic class JwtAuthenticationTokenFilter extends OncePerRequestFilter &#123; @Autowired SelfUserDetailsService userDetailsService; @Override protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain) throws ServletException, IOException &#123; String authHeader = request.getHeader(&quot;Authorization&quot;); if (authHeader != null &amp;&amp; authHeader.startsWith(&quot;Bearer &quot;)) &#123; String authToken = authHeader.substring(&quot;Bearer &quot;.length()); String username = JwtTokenUtil.parseToken(authToken, &quot;_secret&quot;); if (username != null &amp;&amp; SecurityContextHolder.getContext().getAuthentication() == null) &#123; UserDetails userDetails = userDetailsService.loadUserByUsername(username); if (userDetails != null) &#123; UsernamePasswordAuthenticationToken authentication = new UsernamePasswordAuthenticationToken(userDetails, null, userDetails.getAuthorities()); authentication.setDetails(new WebAuthenticationDetailsSource().buildDetails(request)); SecurityContextHolder.getContext().setAuthentication(authentication); &#125; &#125; &#125; filterChain.doFilter(request, response); &#125;&#125; 这里使用到了SelfUserDetailsService，主要是用来做一个用户认证，接下来是相关实现 ##springsecurity核心处理 SelfUserDetailsService实现，继承自UserDetailsService 123456789101112131415161718192021222324252627282930313233343536373839404142package com.sjiay.permission.service;import com.sjiay.permission.entity.SelfUserDetails;import com.sjiay.permission.mapper.UserMapper;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.security.core.GrantedAuthority;import org.springframework.security.core.authority.SimpleGrantedAuthority;import org.springframework.security.core.userdetails.UserDetails;import org.springframework.security.core.userdetails.UserDetailsService;import org.springframework.security.core.userdetails.UsernameNotFoundException;import org.springframework.stereotype.Component;import java.util.HashSet;import java.util.Set;/** * 用户认证、权限 */@Componentpublic class SelfUserDetailsService implements UserDetailsService &#123; @Autowired private UserMapper userMapper; @Override public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException &#123; //通过username查询用户 SelfUserDetails user = userMapper.getUser(username); if(user == null)&#123; //仍需要细化处理 throw new UsernameNotFoundException(&quot;该用户不存在&quot;); &#125; Set authoritiesSet = new HashSet(); // 模拟从数据库中获取用户角色 GrantedAuthority authority = new SimpleGrantedAuthority(&quot;ROLE_ADMIN&quot;); authoritiesSet.add(authority); user.setAuthorities(authoritiesSet); return user; &#125;&#125; mapper以及对应xml实现 123456789101112package com.sjiay.permission.mapper;import com.sjiay.permission.entity.SelfUserDetails;import org.apache.ibatis.annotations.Param;import org.springframework.stereotype.Repository;@Repositorypublic interface UserMapper &#123; //通过username查询用户 SelfUserDetails getUser(@Param(&quot;username&quot;) String username);&#125; 12345678910&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot; &gt;&lt;mapper namespace=&quot;com.sjiay.permission.mapper.UserMapper&quot;&gt; &lt;select id=&quot;getUser&quot; parameterType=&quot;String&quot; resultType=&quot;com.sjiay.permission.entity.SelfUserDetails&quot;&gt; SELECT * FROM user where username = #&#123;username&#125; &lt;/select&gt;&lt;/mapper&gt; security核心处理类 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889package com.sjiay.common.config;import com.sjiay.common.security.*;import com.sjiay.common.filters.JwtAuthenticationTokenFilter;import com.sjiay.permission.service.SelfUserDetailsService;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.context.annotation.Configuration;import org.springframework.security.config.annotation.authentication.builders.AuthenticationManagerBuilder;import org.springframework.security.config.annotation.web.builders.HttpSecurity;import org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter;import org.springframework.security.config.http.SessionCreationPolicy;import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;import org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter;@Configurationpublic class SpringSecurityConf extends WebSecurityConfigurerAdapter &#123; //未登陆时返回 JSON 格式的数据给前端（否则为 html） @Autowired AjaxAuthenticationEntryPoint authenticationEntryPoint; //登录成功返回的 JSON 格式数据给前端（否则为 html） @Autowired AjaxAuthenticationSuccessHandler authenticationSuccessHandler; //登录失败返回的 JSON 格式数据给前端（否则为 html） @Autowired AjaxAuthenticationFailureHandler authenticationFailureHandler; //注销成功返回的 JSON 格式数据给前端（否则为 登录时的 html） @Autowired AjaxLogoutSuccessHandler logoutSuccessHandler; //无权访问返回的 JSON 格式数据给前端（否则为 403 html 页面） @Autowired AjaxAccessDeniedHandler accessDeniedHandler; // 自定义user @Autowired SelfUserDetailsService userDetailsService; // JWT 拦截器 @Autowired JwtAuthenticationTokenFilter jwtAuthenticationTokenFilter; @Override protected void configure(AuthenticationManagerBuilder auth) throws Exception &#123;// auth.inMemoryAuthentication().// passwordEncoder(new MyPasswordEncoder()).// withUser(&quot;admin&quot;).password(&quot;123456&quot;).roles(&quot;ADMIN&quot;); auth.userDetailsService(userDetailsService).passwordEncoder(new BCryptPasswordEncoder()); &#125; @Override protected void configure(HttpSecurity http) throws Exception &#123; //去掉CSRF http.csrf().disable() .sessionManagement().sessionCreationPolicy(SessionCreationPolicy.STATELESS)// 使用 JWT，关闭token .and() .httpBasic().authenticationEntryPoint(authenticationEntryPoint) .and() .authorizeRequests()//定义哪些URL需要被保护、哪些不需要被保护// .antMatchers(&quot;/test/register&quot;)//允许匿名注册// .permitAll() .anyRequest()//任何请求,登录后可以访问 .access(&quot;@rbacauthorityservice.hasPermission(request,authentication)&quot;)// RBAC 动态 url 认证 .and() .formLogin()//开启登录, 定义当需要用户登录时候，转到的登录页面 // .loginPage(&quot;/test/login.html&quot;) // .loginProcessingUrl(&quot;/login&quot;) .successHandler(authenticationSuccessHandler)//登录成功 .failureHandler(authenticationFailureHandler)//登录失败 .permitAll() .and() .logout()//默认注销行为为logout .logoutUrl(&quot;/logout&quot;) .logoutSuccessHandler(logoutSuccessHandler) .permitAll(); //记住我 http.rememberMe().rememberMeParameter(&quot;remember-me&quot;) .userDetailsService(userDetailsService).tokenValiditySeconds(1000); http.exceptionHandling().accessDeniedHandler(accessDeniedHandler);// 无权访问 JSON 格式的数据 http.addFilterBefore(jwtAuthenticationTokenFilter, UsernamePasswordAuthenticationFilter.class); &#125;&#125; ok,我们开始使用postman进行测试登录成功复制返回的token值，进行getUser测试请求成功！ 四、集成日志logback五、集成redis","categories":[{"name":"后端","slug":"后端","permalink":"https://Sjiay1023.github.io/categories/后端/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"https://Sjiay1023.github.io/tags/Spring/"}]},{"title":"SpringBoot集成通用mapper","slug":"SpringBoot集成通用mapper","date":"2019-08-26T08:35:22.000Z","updated":"2019-08-28T07:04:02.385Z","comments":true,"path":"2019/08/26/SpringBoot集成通用mapper/","link":"","permalink":"https://Sjiay1023.github.io/2019/08/26/SpringBoot集成通用mapper/","excerpt":"原先使用的mybatis-generator-core会生成大量example的文件影响后期维护以及数据库的迁移，所以考虑对用通用mapper项目做一次啊重构减少项目代码的耦合性，以下是具体流程以及重构过程各中遇到的坑。[官方文档]（https://mapperhelper.github.io/docs/）","text":"原先使用的mybatis-generator-core会生成大量example的文件影响后期维护以及数据库的迁移，所以考虑对用通用mapper项目做一次啊重构减少项目代码的耦合性，以下是具体流程以及重构过程各中遇到的坑。[官方文档]（https://mapperhelper.github.io/docs/） #主要环境编译器使用IDEA，数据库使用Mysql8.0.14，构建工具使用gradle 一、添加依赖1234567891011121314151617181920212223242526272829303132333435363738394041424344454647buildscript &#123; ext &#123; springBootVersion = &apos;2.1.2.RELEASE&apos; &#125; repositories &#123; mavenCentral() &#125; dependencies &#123; classpath(&quot;org.springframework.boot:spring-boot-gradle-plugin:$&#123;springBootVersion&#125;&quot;) &#125;&#125;apply plugin: &apos;java&apos;apply plugin: &apos;org.springframework.boot&apos;apply plugin: &apos;io.spring.dependency-management&apos;group = &apos;mhh&apos;version = &apos;1.0&apos;sourceCompatibility = &apos;1.8&apos;repositories &#123; mavenLocal() mavenCentral()&#125;ext &#123; set(&apos;springCloudVersion&apos;, &apos;Greenwich.RC2&apos;)&#125;dependencies &#123; runtimeOnly &apos;mysql:mysql-connector-java&apos; testImplementation &apos;org.springframework.boot:spring-boot-starter-test&apos; compile group: &apos;org.mybatis.generator&apos;, name: &apos;mybatis-generator-core&apos;, version: &apos;1.3.5&apos; compile group: &apos;tk.mybatis&apos;, name: &apos;mapper&apos;, version: &apos;4.0.3&apos; compile group: &apos;com.github.pagehelper&apos;, name: &apos;pagehelper-spring-boot-starter&apos;, version: &apos;1.2.5&apos; compile group: &apos;com.alibaba&apos;, name: &apos;druid-spring-boot-starter&apos;, version: &apos;1.1.10&apos; compile group: &apos;org.springframework&apos;, name: &apos;spring-jdbc&apos;, version: &apos;5.1.4.RELEASE&apos;&#125;dependencyManagement &#123; imports &#123; mavenBom &quot;org.springframework.cloud:spring-cloud-dependencies:$&#123;springCloudVersion&#125;&quot; &#125;&#125;bootJar &#123; destinationDir = rootProject.file(&apos;build/libs&apos;) archiveName = &apos;app.jar&apos;&#125; 二、创建BaseMapper123456789101112package com.sjiay.demo.config;import tk.mybatis.mapper.common.Mapper;import tk.mybatis.mapper.common.MySqlMapper;/** * BaseMapper继承通用mapper * @param &lt;T&gt; */public interface BaseMapper&lt;T&gt; extends Mapper&lt;T&gt;, MySqlMapper&lt;T&gt; &#123;&#125; 注意：上面创建的接口不能被@MapperScan扫描到，否则会报错，因为继承了通用mapper，会有很多相应的方法，被扫描到以后，mybatis发现没有一个xml配置文件或者相应方法没有进行实现，这时候就会报错Mapper3提供的所有方法可查看[官方文档]（https://mapperhelper.github.io/docs/） 三、配置application.yml 12345678910111213141516171819202122232425262728server: port: 30020spring: jackson: date-format: yyyy-MM-dd HH:mm:ss time-zone: Asia/Shanghai application: name: demo datasource: driver-class-name: com.mysql.cj.jdbc.Driver url: jdbc:mysql://xxx.xxx.xx.xx:3306/db_name?useUnicode=true&amp;characterEncoding=utf8&amp;serverTimezone=UTC username: db_username password: db_passwordmybatis: mapper-locations: classpath*:/mappers/**/*Mapper.xml configuration: map-underscore-to-camel-case: true use-generated-keys: true default-fetch-size: 100 default-statement-timeout: 30mapper: #mappers 多个接口时逗号隔开 mappers: com.sjiay.demo.config.BaseMapper not-empty: false identity: MYSQL 四、自动化生成配置generatorConfig.xml配置在resource目录下增加generatorConfig.xml文件 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE generatorConfiguration PUBLIC &quot;-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd&quot;&gt;&lt;generatorConfiguration&gt; &lt;!-- context:运行环境，包含大部分的配置信息 id：这个运行环境的唯一标示 targetRuntime：配置生成代码风格。默认就是MyBatis3，还可以设置MyBatis3Simple，这里使用MyBatis3Simple不会生成example等复杂条件 --&gt; &lt;context id=&quot;testContext&quot; targetRuntime=&quot;MyBatis3Simple&quot; defaultModelType=&quot;flat&quot;&gt; &lt;property name=&quot;javaFileEncoding&quot; value=&quot;UTF-8&quot; /&gt; &lt;!--注意配置useMapperCommentGenerator，避免生成较多无用注解，此处也支持自定义注解以及版本差异在此处的配置不一样，建议使用4.0+--&gt; &lt;property name=&quot;useMapperCommentGenerator&quot; value=&quot;false&quot; /&gt; &lt;plugin type=&quot;tk.mybatis.mapper.generator.MapperPlugin&quot;&gt; &lt;!--配置上一步设置的BaseMapper，使之后生成的具体业务mapper自动继承自BaseMapper--&gt; &lt;property name=&quot;mappers&quot; value=&quot;com.com.sjiay.config.BaseMapper&quot; /&gt; &lt;!--caseSensitive默认false，当数据库表名区分大小写时，可以将该属性设置为true--&gt; &lt;property name=&quot;caseSensitive&quot; value=&quot;false&quot;/&gt; &lt;property name=&quot;forceAnnotation&quot; value=&quot;true&quot;/&gt; &lt;property name=&quot;beginningDelimiter&quot; value=&quot;`&quot;/&gt; &lt;property name=&quot;endingDelimiter&quot; value=&quot;`&quot;/&gt; &lt;/plugin&gt; &lt;commentGenerator&gt; &lt;!-- 是否去除自动生成的注释 true：是 ： false:否 --&gt; &lt;property name=&quot;suppressAllComments&quot; value=&quot;true&quot; /&gt; &lt;!-- 是否去除日期注释 --&gt; &lt;property name=&quot;suppressDate&quot; value=&quot;true&quot; /&gt; &lt;/commentGenerator&gt; &lt;!--数据库连接的信息：驱动类、连接地址、表名 、用户名、密码 ,此处也可通过读取配置文件的方式来设置--&gt; &lt;jdbcConnection driverClass=&quot;com.mysql.cj.jdbc.Driver&quot; connectionURL=&quot;jdbc:mysql://xxx.xxx.xx.xx:3306/db_name&quot; userId=&quot;db_username&quot; password=&quot;db_password&quot;&gt; &lt;/jdbcConnection&gt; &lt;!-- 默认false,会根据数据精度来判断转换为Java什么类型。推荐 为 true时会强制把数据库Decimal、Numeric数据类型解析为java.math.BigDecimal --&gt; &lt;javaTypeResolver&gt; &lt;property name=&quot;forceBigDecimals&quot; value=&quot;false&quot; /&gt; &lt;/javaTypeResolver&gt; &lt;!-- javaModelGenerator:有关实体类的配置 targetPackage:生成实体类所在包 targetProject:生成POJO类的位置 --&gt; &lt;javaModelGenerator targetPackage=&quot;com.sjiay.demo.entity&quot; targetProject=&quot;src/main/java&quot;&gt; &lt;!-- 是否根据表schema生成子包 --&gt; &lt;property name=&quot;enableSubPackages&quot; value=&quot;false&quot; /&gt; &lt;!-- 是否清理 从数据库返回的值前后的空格 --&gt; &lt;property name=&quot;trimStrings&quot; value=&quot;true&quot; /&gt; &lt;/javaModelGenerator&gt; &lt;!-- sqlMapGenerator：有关映射文件的配置，属性跟上面的javaModelGenerator类似 targetPackage：指定mapper.xml所在包名 targetProject：指定在项目中存放的位置，因为是maven工程，所以放在resource下。 最终Mapper.xml文件的目录就是 src/main/resources下的mappers目录下 --&gt; &lt;sqlMapGenerator targetPackage=&quot;mappers&quot; targetProject=&quot;src/main/resources&quot;&gt; &lt;property name=&quot;enableSubPackages&quot; value=&quot;false&quot; /&gt; &lt;/sqlMapGenerator&gt; &lt;!-- javaClientGenerator：有关Mapper接口的配置，属性跟上面的javaModelGenerator类似 type=&quot;XMLMAPPER&quot;：设置以XML格式生成映射而非注解 --&gt; &lt;javaClientGenerator type=&quot;XMLMAPPER&quot; targetPackage=&quot;com.sjiay.demo..mapper&quot; targetProject=&quot;src/main/java&quot;&gt; &lt;property name=&quot;enableSubPackages&quot; value=&quot;false&quot; /&gt; &lt;/javaClientGenerator&gt; &lt;!-- 指定数据库表 catalog：数据库里的catalog tableName：表的名称 domainObjectName：指定表对应生成实体类的名称 --&gt; &lt;table tableName=&quot;demo_user&quot; domainObjectName=&quot;user&quot;&gt; &lt;!-- 设置自增ID的回显功能 --&gt; &lt;!--&lt;generatedKey column=&quot;id&quot; sqlStatement=&quot;Mysql&quot;/&gt;--&gt; &lt;/table&gt; &lt;/context&gt;&lt;/generatorConfiguration&gt; 新建自动生成工具类 在SpringBoot同级目录新建GeneratorTest.java类，当然也可在其他项目，此类会覆盖原先改动，所以慎重运行！ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455 package com.sjiay.demo;import org.apache.ibatis.io.Resources;import org.mybatis.generator.api.MyBatisGenerator;import org.mybatis.generator.config.Configuration;import org.mybatis.generator.config.xml.ConfigurationParser;import org.mybatis.generator.internal.DefaultShellCallback;import java.io.InputStream;import java.text.SimpleDateFormat;import java.util.ArrayList;import java.util.Date;import java.util.List;/** * @author o_0sky * @date 2019/6/20 18:01 */public class GeneratorTest &#123; public static void main(String[] args) throws Exception &#123; String today = &quot;2019-08-14&quot;; SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy-MM-dd&quot;); Date now = sdf.parse(today); Date d = new Date(); if (d.getTime() &gt; now.getTime() + 1000 * 60 * 60 * 24) &#123; System.err.println(&quot;——————未成成功运行——————&quot;); System.err.println(&quot;——————未成成功运行——————&quot;); System.err.println(&quot;本程序具有破坏作用，应该只运行一次，如果必须要再运行，需要修改today变量为今天，如:&quot; + sdf.format(new Date())); return; &#125; if (false) return; List&lt;String&gt; warnings = new ArrayList&lt;String&gt;(); // 是否覆盖以前生成的重复代码 boolean overwrite = true; // 配置文件的资源路径，会去classpath下找。maven项目中，就是resource下 InputStream in = Resources.getResourceAsStream(&quot;generatorConfig.xml&quot;); // 配置解析器 ConfigurationParser cp = new ConfigurationParser(warnings); // 加载配置文件，并解析 Configuration config = cp.parseConfiguration(in); DefaultShellCallback callback = new DefaultShellCallback(overwrite); // 获取MBG对象 MyBatisGenerator myBatisGenerator = new MyBatisGenerator(config, callback, warnings); // 生成代码 myBatisGenerator.generate(null); for (String warning : warnings) &#123; System.out.println(warning); &#125; &#125;&#125; 运行GeneratorTest类，会在entity包下生成实体，mapper包下生成mapper接口，以及resources下mappers目录下对应的mapper.xml文件 五、配置SpringBoot启动类1234567891011121314package com.mhh.menzhengljk;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import tk.mybatis.spring.annotation.MapperScan;@MapperScan(value = &quot;com.sjiay.demo.mapper&quot;)@SpringBootApplicationpublic class DemoApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(DemoApplication.class, args); &#125;&#125; 注意：此处要扫描对应生成的mapper接口，MapperScan是tk.mybatis.spring.annotation.MapperScan,而不是org下的MapperScan。 六、实体公共实体封装在实际项目中会会传一些公共参数，如时间区间，分页参数每页显示的行数和显示第几行等，此处使用BaseEntity进行封装，然后让自动生成的实体类继承这个公共实体，算是对原先实体的一个扩展。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253package com.sjiay.demo.entity;import javax.persistence.Transient;import javax.validation.constraints.NotEmpty;public class BaseEntity &#123; @NotEmpty @Transient private String riqi1; @NotEmpty @Transient private String riqi2; @Transient private Integer rows; @Transient private Integer page; public String getRiqi1() &#123; return riqi1; &#125; public void setRiqi1(String riqi1) &#123; this.riqi1 = riqi1; &#125; public String getRiqi2() &#123; return riqi2; &#125; public void setRiqi2(String riqi2) &#123; this.riqi2 = riqi2; &#125; public Integer getRows() &#123; return rows; &#125; public void setRows(Integer rows) &#123; this.rows = rows; &#125; public Integer getPage() &#123; return page; &#125; public void setPage(Integer page) &#123; this.page = page; &#125;&#125; 业务实体实现对应生成的实体类让其继承上面的公共实体类，具体如下： 12345678910111213141516171819202122232425262728293031323334353637package com.mhh.menzhengljk.entity;import javax.persistence.Table;@Table(name = &quot;user&quot;)public class user extends BaseEntity&#123; private Integer userid; private String username; private String chushengrq; public Integer getUserid() &#123; return userid; &#125; public void setUserid(Integer userid) &#123; this.userid = userid; &#125; public String getUsername() &#123; return username; &#125; public void setUsername(String username) &#123; this.username = username; &#125; public String getChushengrq() &#123; return chushengrq; &#125; public void setChushengrq(String chushengrq) &#123; this.chushengrq = chushengrq; &#125;&#125; 此处对出生日期做一个区间查询，我这边业务要求上日期使用了String，一般是可以直接用date去存储。 七、Service实现公共Service封装你当然可以在controller中注入mapper进行开发，而在实际开发过程中一般都会使用Service做一些逻辑判断，以及事务的控制，这里主要简单对加了通用mapper之后怎么封装做了演示，主要是让所有Service继承一个BaseService，这样就可以保证所有Service都有通用mapper的方法。 公共Servicee接口： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147package com.sjiay.demo.service.base;import com.sjiay.demo.entity.BaseEntity;import org.apache.ibatis.annotations.Param;import java.util.List;public interface BaseService &lt;T extends BaseEntity&gt;&#123; /** * 只获取一条数据，当查询的结果多于一条数据时抛出异常。如果只想获取检索结果的第一条数据请一部 @see selectFirst * * @param record * @return */ T selectOne(T record); /** * 根据条件查询返回数据列表 * * @param record * @return */ List&lt;T&gt; select(T record); /** * 根据主键查询 * * @param pk 主键 * @return */ T selectByPrimaryKey(Object pk); /** * 根据条件查询返回数据条数 * * @param record * @return */ int selectCount(T record); /** * 查询返回所有数据列表 * * @param * @return */ List&lt;T&gt; selectAll(); /** * 根据条件查询返回数据列表 * * @param example * @return */ List&lt;T&gt; selectByExample(Object example); /** * 根据Example条件进行查询总数 * * @param example * @return */ int selectCountByExample(Object example); /** * 根据Example条件更新实体record包含的全部属性，null值会被更新 * * @param record example * @return */ int updateByExample(@Param(&quot;record&quot;) T record, @Param(&quot;example&quot;) Object example); /** * 根据Example条件更新实体record包含的不是null的属性值 * * @param record example * @return */ int updateByExampleSelective(@Param(&quot;record&quot;) T record, @Param(&quot;example&quot;) Object example); /** * 根据Example条件删除数据 * * @param example * @return */ int deleteByExample(Object example); /** * 保存一个实体，null的属性也会保存，不会使用数据库默认值 * * @param record * @return */ int insert(T record); /** * 保存一个实体，null的属性不会保存，会使用数据库默认值 * * @param record * @return */ int insertSelective(T record); /** * 插入列表，空属性不会插入 * * @param recordList * @return */ int insertListSelective(List&lt;T&gt; recordList); /** * 根据主键更新实体全部字段，null值会被更新 * * @param record * @return */ int updateByPrimaryKey(T record); /** * 根据主键更新属性不为null的值 * * @param record * @return */ int updateByPrimaryKeySelective(T record); /** * 根据实体属性作为条件进行删除，查询条件使用等号 * * @param record * @return */ int delete(T record); /** * 根据主键字段进行删除，方法参数必须包含完整的主键属性 * * @param key * @return */ int deleteByPrimaryKey(Object key);&#125; 公共Service具体实现： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105package com.sjiay.demo.service.base.impl;import com.sjiay.demo.config.BaseMapper;import com.sjiay.demo.entity.BaseEntity;import com.sjiay.demo.service.base.BaseService;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Service;import java.util.List;@Servicepublic class BaseServiceImpl&lt;T extends BaseEntity&gt; implements BaseService&lt;T&gt; &#123; @Autowired private BaseMapper&lt;T&gt; baseMapper; @Override public T selectOne(T record) &#123; return baseMapper.selectOne(record); &#125; @Override public List&lt;T&gt; select(T record) &#123; return baseMapper.select(record); &#125; @Override public T selectByPrimaryKey(Object pk) &#123; if (pk == null) &#123; return null; &#125; return baseMapper.selectByPrimaryKey(pk); &#125; @Override public int selectCount(T record) &#123; return baseMapper.selectCount(record); &#125; @Override public List&lt;T&gt; selectAll() &#123; return baseMapper.selectAll(); &#125; @Override public List&lt;T&gt; selectByExample(Object example) &#123; return baseMapper.selectByExample(example); &#125; @Override public int selectCountByExample(Object example) &#123; return baseMapper.selectCountByExample(example); &#125; @Override public int updateByExample(T record, Object example) &#123; return baseMapper.updateByExample(record,example); &#125; @Override public int updateByExampleSelective(T record, Object example) &#123; return baseMapper.updateByExampleSelective(record,example); &#125; @Override public int deleteByExample(Object example) &#123; return baseMapper.deleteByExample(example); &#125; @Override public int insert(T record) &#123; return baseMapper.insert(record); &#125; @Override public int insertSelective(T record) &#123; return baseMapper.insertSelective(record); &#125; @Override public int insertListSelective(List&lt;T&gt; recordList) &#123; for (T record : recordList) &#123; baseMapper.insertSelective(record); &#125; return 1; &#125; @Override public int updateByPrimaryKey(T record) &#123; return baseMapper.updateByPrimaryKey(record); &#125; @Override public int updateByPrimaryKeySelective(T record) &#123; return baseMapper.updateByPrimaryKeySelective(record); &#125; @Override public int delete(T record) &#123; return baseMapper.delete(record); &#125; @Override public int deleteByPrimaryKey(Object key) &#123; return baseMapper.deleteByPrimaryKey(key); &#125;&#125; 业务Service实现将通用mapper中一些常用的方法进行实现，业务Service此处就省略（需要继承公共Service接口）具体业务类的Service可实现如下： 1234567891011package com.sjiay.demo.service.wszy.impl;import com.sjiay.demo.entity.user;import com.sjiay.demo.service.base.impl.BaseServiceImpl;import com.sjiay.demo.service.wszy.UserService;import org.springframework.stereotype.Service;@Servicepublic class UserServiceImpl extends BaseServiceImpl&lt;user&gt; implements UserService &#123;&#125; 在只有通用方法时就不需要加任何方法，是不是显得特别简约方便。 八、测试一下12345678910111213141516171819202122232425262728293031323334353637package com.sjiay.demo.controller;import com.dongfang.mhh.mhhbase.ResMsg;import com.dongfang.mhh.mhhbase.ResMsgpage;import com.github.pagehelper.PageHelper;import com.github.pagehelper.PageInfo;import com.sjiay.demo.service.wszy.UserService;import com.sjiay.demo.entity.XzyyFuwujg;import org.apache.commons.lang.StringUtils;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.web.bind.annotation.*;import tk.mybatis.mapper.entity.Example;import java.util.List;@RestController@RequestMapping(&quot;/demo&quot;)public class UserController &#123; @Autowired private UserService userService; /** * 获取用户列表 */ @PostMapping(&quot;/getUserList&quot;) public ResMsgpage getJgxxList(@RequestBody User user) &#123; Example example = new Example(User.class); Example.Criteria criteria = example.createCriteria(); criteria.andBetween(&quot;chushengrq&quot;,user.getRiqi1(),user.getRiqi2()); example.and(criteria); PageHelper.startPage(user.getPage(), user.getRows(), true); List&lt;User&gt; userList = userService.selectByExample(example); PageInfo&lt;User&gt; pageInfo=new PageInfo&lt;User&gt;(userList); Long page = Long.valueOf(user.getPage()); Long total = Long.valueOf(pageInfo.getPages()); return new ResMsgpage(userList,page,pageInfo.getTotal(),total); &#125; 实际项目中上面的返回结果集都做过封装，简单使用可直接通过List来返回，上述过程都是亲测成功，如有需要用到通用mapper的欢迎参考。上述内容纯属个人总结，如有错误欢迎拍砖！","categories":[{"name":"后端","slug":"后端","permalink":"https://Sjiay1023.github.io/categories/后端/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"https://Sjiay1023.github.io/tags/Spring/"}]},{"title":"第一个博客","slug":"me-first-blog","date":"2019-08-19T10:25:11.000Z","updated":"2019-08-20T09:13:33.536Z","comments":true,"path":"2019/08/19/me-first-blog/","link":"","permalink":"https://Sjiay1023.github.io/2019/08/19/me-first-blog/","excerpt":"欢迎使用Markdown编辑器写博客 //一级标题 对应 标题输入 //二级标题 对应 三级标题 //三级标题 对应 四级标题 //四级标题 对应 五级标题 //五级标题 对应 六级标题 //六级标题 对应 ####### 七级标题 //抱歉，木有了（但是他会影响生成的目录，目录行多出一行空行）","text":"欢迎使用Markdown编辑器写博客 //一级标题 对应 标题输入 //二级标题 对应 三级标题 //三级标题 对应 四级标题 //四级标题 对应 五级标题 //五级标题 对应 六级标题 //六级标题 对应 ####### 七级标题 //抱歉，木有了（但是他会影响生成的目录，目录行多出一行空行） 123#!/usr/bin/env python# -*- coding: utf-8 -*-print 'Hello World! 列1 列2 列3 第1行 12 13 第2行 22 23 第3行 32 33 斜体， 粗体","categories":[{"name":"个人","slug":"个人","permalink":"https://Sjiay1023.github.io/categories/个人/"}],"tags":[{"name":"个人","slug":"个人","permalink":"https://Sjiay1023.github.io/tags/个人/"}]},{"title":"Hello World","slug":"hello-world","date":"2019-08-19T08:37:14.431Z","updated":"2019-08-20T05:59:59.775Z","comments":true,"path":"2019/08/19/hello-world/","link":"","permalink":"https://Sjiay1023.github.io/2019/08/19/hello-world/","excerpt":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}