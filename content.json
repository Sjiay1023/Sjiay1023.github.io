{"meta":{"title":"Hexo","subtitle":null,"description":null,"author":"John Doe","url":"https://Sjiay1023.github.io","root":"/"},"pages":[{"title":"404 Not Found：该页无法显示","date":"2019-08-20T08:04:03.299Z","updated":"2019-08-19T11:30:40.838Z","comments":false,"path":"/404.html","permalink":"https://Sjiay1023.github.io//404.html","excerpt":"","text":""},{"title":"书单","date":"2019-08-20T03:01:43.184Z","updated":"2019-08-19T11:30:40.842Z","comments":false,"path":"books/index.html","permalink":"https://Sjiay1023.github.io/books/index.html","excerpt":"","text":""},{"title":"关于","date":"2019-08-20T08:04:06.398Z","updated":"2019-08-19T11:30:40.840Z","comments":false,"path":"about/index.html","permalink":"https://Sjiay1023.github.io/about/index.html","excerpt":"","text":"个人详细介绍"},{"title":"分类","date":"2019-08-20T08:00:39.670Z","updated":"2019-08-19T11:30:40.842Z","comments":false,"path":"categories/index.html","permalink":"https://Sjiay1023.github.io/categories/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2019-08-20T03:09:21.236Z","updated":"2019-08-19T11:30:40.843Z","comments":true,"path":"links/index.html","permalink":"https://Sjiay1023.github.io/links/index.html","excerpt":"","text":""},{"title":"标签","date":"2019-08-20T08:00:39.653Z","updated":"2019-08-19T11:30:40.844Z","comments":false,"path":"tags/index.html","permalink":"https://Sjiay1023.github.io/tags/index.html","excerpt":"","text":""},{"title":"Repositories","date":"2019-08-20T08:05:31.077Z","updated":"2019-08-19T11:30:40.844Z","comments":false,"path":"repository/index.html","permalink":"https://Sjiay1023.github.io/repository/index.html","excerpt":"","text":""}],"posts":[{"title":"SpringBoot集成通用mapper","slug":"SpringBoot集成通用mapper","date":"2019-08-26T08:35:22.000Z","updated":"2019-08-27T09:02:42.468Z","comments":true,"path":"2019/08/26/SpringBoot集成通用mapper/","link":"","permalink":"https://Sjiay1023.github.io/2019/08/26/SpringBoot集成通用mapper/","excerpt":"原先使用的mybatis-generator-core会生成大量example的文件影响后期维护以及数据库的迁移，所以考虑对用通用mapper项目做一次啊重构减少项目代码的耦合性，以下是具体流程以及重构过程各中遇到的坑。[官方文档]（https://mapperhelper.github.io/docs/）","text":"原先使用的mybatis-generator-core会生成大量example的文件影响后期维护以及数据库的迁移，所以考虑对用通用mapper项目做一次啊重构减少项目代码的耦合性，以下是具体流程以及重构过程各中遇到的坑。[官方文档]（https://mapperhelper.github.io/docs/） #主要环境编译器使用IDEA，数据库使用Mysql8.0.14，构建工具使用gradle 一、添加依赖1234567891011121314151617181920212223242526272829303132333435363738394041424344454647buildscript &#123; ext &#123; springBootVersion = &apos;2.1.2.RELEASE&apos; &#125; repositories &#123; mavenCentral() &#125; dependencies &#123; classpath(&quot;org.springframework.boot:spring-boot-gradle-plugin:$&#123;springBootVersion&#125;&quot;) &#125;&#125;apply plugin: &apos;java&apos;apply plugin: &apos;org.springframework.boot&apos;apply plugin: &apos;io.spring.dependency-management&apos;group = &apos;mhh&apos;version = &apos;1.0&apos;sourceCompatibility = &apos;1.8&apos;repositories &#123; mavenLocal() mavenCentral()&#125;ext &#123; set(&apos;springCloudVersion&apos;, &apos;Greenwich.RC2&apos;)&#125;dependencies &#123; runtimeOnly &apos;mysql:mysql-connector-java&apos; testImplementation &apos;org.springframework.boot:spring-boot-starter-test&apos; compile group: &apos;org.mybatis.generator&apos;, name: &apos;mybatis-generator-core&apos;, version: &apos;1.3.5&apos; compile group: &apos;tk.mybatis&apos;, name: &apos;mapper&apos;, version: &apos;4.0.3&apos; compile group: &apos;com.github.pagehelper&apos;, name: &apos;pagehelper-spring-boot-starter&apos;, version: &apos;1.2.5&apos; compile group: &apos;com.alibaba&apos;, name: &apos;druid-spring-boot-starter&apos;, version: &apos;1.1.10&apos; compile group: &apos;org.springframework&apos;, name: &apos;spring-jdbc&apos;, version: &apos;5.1.4.RELEASE&apos;&#125;dependencyManagement &#123; imports &#123; mavenBom &quot;org.springframework.cloud:spring-cloud-dependencies:$&#123;springCloudVersion&#125;&quot; &#125;&#125;bootJar &#123; destinationDir = rootProject.file(&apos;build/libs&apos;) archiveName = &apos;app.jar&apos;&#125; 二、创建BaseMapper123456789101112package com.sjiay.demo.config;import tk.mybatis.mapper.common.Mapper;import tk.mybatis.mapper.common.MySqlMapper;/** * BaseMapper继承通用mapper * @param &lt;T&gt; */public interface BaseMapper&lt;T&gt; extends Mapper&lt;T&gt;, MySqlMapper&lt;T&gt; &#123;&#125; 注意：上面创建的接口不能被扫描到，否则会报错，Mapper3提供的所有方法可查看[官方文档]（https://mapperhelper.github.io/docs/） 三、配置application.yml 12345678910111213141516171819202122232425262728server: port: 30020spring: jackson: date-format: yyyy-MM-dd HH:mm:ss time-zone: Asia/Shanghai application: name: demo datasource: driver-class-name: com.mysql.cj.jdbc.Driver url: jdbc:mysql://xxx.xxx.xx.xx:3306/db_name?useUnicode=true&amp;characterEncoding=utf8&amp;serverTimezone=UTC username: db_username password: db_passwordmybatis: mapper-locations: classpath*:/mappers/**/*Mapper.xml configuration: map-underscore-to-camel-case: true use-generated-keys: true default-fetch-size: 100 default-statement-timeout: 30mapper: #mappers 多个接口时逗号隔开 mappers: com.sjiay.demo.config.BaseMapper not-empty: false identity: MYSQL 四、自动化生成配置generatorConfig.xml配置在resource目录下增加generatorConfig.xml文件 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE generatorConfiguration PUBLIC &quot;-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd&quot;&gt;&lt;generatorConfiguration&gt; &lt;!-- context:运行环境，包含大部分的配置信息 id：这个运行环境的唯一标示 targetRuntime：配置生成代码风格。默认就是MyBatis3，还可以设置MyBatis3Simple，这里使用MyBatis3Simple不会生成example等复杂条件 --&gt; &lt;context id=&quot;testContext&quot; targetRuntime=&quot;MyBatis3Simple&quot; defaultModelType=&quot;flat&quot;&gt; &lt;property name=&quot;javaFileEncoding&quot; value=&quot;UTF-8&quot; /&gt; &lt;!--注意配置useMapperCommentGenerator，避免生成较多无用注解，此处也支持自定义注解以及版本差异在此处的配置不一样，建议使用4.0+--&gt; &lt;property name=&quot;useMapperCommentGenerator&quot; value=&quot;false&quot; /&gt; &lt;plugin type=&quot;tk.mybatis.mapper.generator.MapperPlugin&quot;&gt; &lt;!--配置上一步设置的BaseMapper，使之后生成的具体业务mapper自动继承自BaseMapper--&gt; &lt;property name=&quot;mappers&quot; value=&quot;com.com.sjiay.config.BaseMapper&quot; /&gt; &lt;!--caseSensitive默认false，当数据库表名区分大小写时，可以将该属性设置为true--&gt; &lt;property name=&quot;caseSensitive&quot; value=&quot;false&quot;/&gt; &lt;property name=&quot;forceAnnotation&quot; value=&quot;true&quot;/&gt; &lt;property name=&quot;beginningDelimiter&quot; value=&quot;`&quot;/&gt; &lt;property name=&quot;endingDelimiter&quot; value=&quot;`&quot;/&gt; &lt;/plugin&gt; &lt;commentGenerator&gt; &lt;!-- 是否去除自动生成的注释 true：是 ： false:否 --&gt; &lt;property name=&quot;suppressAllComments&quot; value=&quot;true&quot; /&gt; &lt;!-- 是否去除日期注释 --&gt; &lt;property name=&quot;suppressDate&quot; value=&quot;true&quot; /&gt; &lt;/commentGenerator&gt; &lt;!--数据库连接的信息：驱动类、连接地址、表名 、用户名、密码 ,此处也可通过读取配置文件的方式来设置--&gt; &lt;jdbcConnection driverClass=&quot;com.mysql.cj.jdbc.Driver&quot; connectionURL=&quot;jdbc:mysql://xxx.xxx.xx.xx:3306/db_name&quot; userId=&quot;db_username&quot; password=&quot;db_password&quot;&gt; &lt;/jdbcConnection&gt; &lt;!-- 默认false,会根据数据精度来判断转换为Java什么类型。推荐 为 true时会强制把数据库Decimal、Numeric数据类型解析为java.math.BigDecimal --&gt; &lt;javaTypeResolver&gt; &lt;property name=&quot;forceBigDecimals&quot; value=&quot;false&quot; /&gt; &lt;/javaTypeResolver&gt; &lt;!-- javaModelGenerator:有关实体类的配置 targetPackage:生成实体类所在包 targetProject:生成POJO类的位置 --&gt; &lt;javaModelGenerator targetPackage=&quot;com.sjiay.demo.entity&quot; targetProject=&quot;src/main/java&quot;&gt; &lt;!-- 是否根据表schema生成子包 --&gt; &lt;property name=&quot;enableSubPackages&quot; value=&quot;false&quot; /&gt; &lt;!-- 是否清理 从数据库返回的值前后的空格 --&gt; &lt;property name=&quot;trimStrings&quot; value=&quot;true&quot; /&gt; &lt;/javaModelGenerator&gt; &lt;!-- sqlMapGenerator：有关映射文件的配置，属性跟上面的javaModelGenerator类似 targetPackage：指定mapper.xml所在包名 targetProject：指定在项目中存放的位置，因为是maven工程，所以放在resource下。 最终Mapper.xml文件的目录就是 src/main/resources下的mappers目录下 --&gt; &lt;sqlMapGenerator targetPackage=&quot;mappers&quot; targetProject=&quot;src/main/resources&quot;&gt; &lt;property name=&quot;enableSubPackages&quot; value=&quot;false&quot; /&gt; &lt;/sqlMapGenerator&gt; &lt;!-- javaClientGenerator：有关Mapper接口的配置，属性跟上面的javaModelGenerator类似 type=&quot;XMLMAPPER&quot;：设置以XML格式生成映射而非注解 --&gt; &lt;javaClientGenerator type=&quot;XMLMAPPER&quot; targetPackage=&quot;com.sjiay.demo..mapper&quot; targetProject=&quot;src/main/java&quot;&gt; &lt;property name=&quot;enableSubPackages&quot; value=&quot;false&quot; /&gt; &lt;/javaClientGenerator&gt; &lt;!-- 指定数据库表 catalog：数据库里的catalog tableName：表的名称 domainObjectName：指定表对应生成实体类的名称 --&gt; &lt;table tableName=&quot;demo_user&quot; domainObjectName=&quot;user&quot;&gt; &lt;!-- 设置自增ID的回显功能 --&gt; &lt;!--&lt;generatedKey column=&quot;id&quot; sqlStatement=&quot;Mysql&quot;/&gt;--&gt; &lt;/table&gt; &lt;/context&gt;&lt;/generatorConfiguration&gt; 新建自动生成工具类 在SpringBoot同级目录新建GeneratorTest.java类，当然也可在其他项目，此类会覆盖原先改动，所以慎重运行！ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455 package com.sjiay.demo;import org.apache.ibatis.io.Resources;import org.mybatis.generator.api.MyBatisGenerator;import org.mybatis.generator.config.Configuration;import org.mybatis.generator.config.xml.ConfigurationParser;import org.mybatis.generator.internal.DefaultShellCallback;import java.io.InputStream;import java.text.SimpleDateFormat;import java.util.ArrayList;import java.util.Date;import java.util.List;/** * @author o_0sky * @date 2019/6/20 18:01 */public class GeneratorTest &#123; public static void main(String[] args) throws Exception &#123; String today = &quot;2019-08-14&quot;; SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy-MM-dd&quot;); Date now = sdf.parse(today); Date d = new Date(); if (d.getTime() &gt; now.getTime() + 1000 * 60 * 60 * 24) &#123; System.err.println(&quot;——————未成成功运行——————&quot;); System.err.println(&quot;——————未成成功运行——————&quot;); System.err.println(&quot;本程序具有破坏作用，应该只运行一次，如果必须要再运行，需要修改today变量为今天，如:&quot; + sdf.format(new Date())); return; &#125; if (false) return; List&lt;String&gt; warnings = new ArrayList&lt;String&gt;(); // 是否覆盖以前生成的重复代码 boolean overwrite = true; // 配置文件的资源路径，会去classpath下找。maven项目中，就是resource下 InputStream in = Resources.getResourceAsStream(&quot;generatorConfig.xml&quot;); // 配置解析器 ConfigurationParser cp = new ConfigurationParser(warnings); // 加载配置文件，并解析 Configuration config = cp.parseConfiguration(in); DefaultShellCallback callback = new DefaultShellCallback(overwrite); // 获取MBG对象 MyBatisGenerator myBatisGenerator = new MyBatisGenerator(config, callback, warnings); // 生成代码 myBatisGenerator.generate(null); for (String warning : warnings) &#123; System.out.println(warning); &#125; &#125;&#125; 运行GeneratorTest类，会在entity包下生成实体，mapper包下生成mapper接口，以及resources下mappers目录下对应的mapper.xml文件 五、配置SpringBoot启动类1234567891011121314package com.mhh.menzhengljk;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import tk.mybatis.spring.annotation.MapperScan;@MapperScan(value = &quot;com.sjiay.demo.mapper&quot;)@SpringBootApplicationpublic class DemoApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(DemoApplication.class, args); &#125;&#125; 注意：此处要扫描对应生成的mapper接口，MapperScan是tk.mybatis.spring.annotation.MapperScan,而不是org下的MapperScan。 六、实体公共实体封装在实际项目中会会传一些公共参数，如时间区间，分页参数每页显示的行数和显示第几行等，此处使用BaseEntity进行封装，然后让自动生成的实体类继承这个公共实体，算是对原先实体的一个扩展。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253package com.sjiay.demo.entity;import javax.persistence.Transient;import javax.validation.constraints.NotEmpty;public class BaseEntity &#123; @NotEmpty @Transient private String riqi1; @NotEmpty @Transient private String riqi2; @Transient private Integer rows; @Transient private Integer page; public String getRiqi1() &#123; return riqi1; &#125; public void setRiqi1(String riqi1) &#123; this.riqi1 = riqi1; &#125; public String getRiqi2() &#123; return riqi2; &#125; public void setRiqi2(String riqi2) &#123; this.riqi2 = riqi2; &#125; public Integer getRows() &#123; return rows; &#125; public void setRows(Integer rows) &#123; this.rows = rows; &#125; public Integer getPage() &#123; return page; &#125; public void setPage(Integer page) &#123; this.page = page; &#125;&#125; 业务实体实现对应生成的实体类让其继承上面的公共实体类，具体如下： 12345678910111213141516171819202122232425262728293031323334353637package com.mhh.menzhengljk.entity;import javax.persistence.Table;@Table(name = &quot;user&quot;)public class user extends BaseEntity&#123; private Integer userid; private String username; private String chushengrq; public Integer getUserid() &#123; return userid; &#125; public void setUserid(Integer userid) &#123; this.userid = userid; &#125; public String getUsername() &#123; return username; &#125; public void setUsername(String username) &#123; this.username = username; &#125; public String getChushengrq() &#123; return chushengrq; &#125; public void setChushengrq(String chushengrq) &#123; this.chushengrq = chushengrq; &#125;&#125; 此处对出生日期做一个区间查询，我这边业务要求上日期使用了String，一般是可以直接用date去存储。 七、Service实现公共Service封装你当然可以在controller中注入mapper进行开发，而在实际开发过程中一般都会使用Service做一些逻辑判断，以及事务的控制，这里主要简单对加了通用mapper之后怎么封装做了演示，主要是让所有Service继承一个BaseService，这样就可以保证所有Service都有通用mapper的方法。 公共Servicee接口： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147package com.sjiay.demo.service.base;import com.sjiay.demo.entity.BaseEntity;import org.apache.ibatis.annotations.Param;import java.util.List;public interface BaseService &lt;T extends BaseEntity&gt;&#123; /** * 只获取一条数据，当查询的结果多于一条数据时抛出异常。如果只想获取检索结果的第一条数据请一部 @see selectFirst * * @param record * @return */ T selectOne(T record); /** * 根据条件查询返回数据列表 * * @param record * @return */ List&lt;T&gt; select(T record); /** * 根据主键查询 * * @param pk 主键 * @return */ T selectByPrimaryKey(Object pk); /** * 根据条件查询返回数据条数 * * @param record * @return */ int selectCount(T record); /** * 查询返回所有数据列表 * * @param * @return */ List&lt;T&gt; selectAll(); /** * 根据条件查询返回数据列表 * * @param example * @return */ List&lt;T&gt; selectByExample(Object example); /** * 根据Example条件进行查询总数 * * @param example * @return */ int selectCountByExample(Object example); /** * 根据Example条件更新实体record包含的全部属性，null值会被更新 * * @param record example * @return */ int updateByExample(@Param(&quot;record&quot;) T record, @Param(&quot;example&quot;) Object example); /** * 根据Example条件更新实体record包含的不是null的属性值 * * @param record example * @return */ int updateByExampleSelective(@Param(&quot;record&quot;) T record, @Param(&quot;example&quot;) Object example); /** * 根据Example条件删除数据 * * @param example * @return */ int deleteByExample(Object example); /** * 保存一个实体，null的属性也会保存，不会使用数据库默认值 * * @param record * @return */ int insert(T record); /** * 保存一个实体，null的属性不会保存，会使用数据库默认值 * * @param record * @return */ int insertSelective(T record); /** * 插入列表，空属性不会插入 * * @param recordList * @return */ int insertListSelective(List&lt;T&gt; recordList); /** * 根据主键更新实体全部字段，null值会被更新 * * @param record * @return */ int updateByPrimaryKey(T record); /** * 根据主键更新属性不为null的值 * * @param record * @return */ int updateByPrimaryKeySelective(T record); /** * 根据实体属性作为条件进行删除，查询条件使用等号 * * @param record * @return */ int delete(T record); /** * 根据主键字段进行删除，方法参数必须包含完整的主键属性 * * @param key * @return */ int deleteByPrimaryKey(Object key);&#125; 公共Service具体实现： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105package com.sjiay.demo.service.base.impl;import com.sjiay.demo.config.BaseMapper;import com.sjiay.demo.entity.BaseEntity;import com.sjiay.demo.service.base.BaseService;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Service;import java.util.List;@Servicepublic class BaseServiceImpl&lt;T extends BaseEntity&gt; implements BaseService&lt;T&gt; &#123; @Autowired private BaseMapper&lt;T&gt; baseMapper; @Override public T selectOne(T record) &#123; return baseMapper.selectOne(record); &#125; @Override public List&lt;T&gt; select(T record) &#123; return baseMapper.select(record); &#125; @Override public T selectByPrimaryKey(Object pk) &#123; if (pk == null) &#123; return null; &#125; return baseMapper.selectByPrimaryKey(pk); &#125; @Override public int selectCount(T record) &#123; return baseMapper.selectCount(record); &#125; @Override public List&lt;T&gt; selectAll() &#123; return baseMapper.selectAll(); &#125; @Override public List&lt;T&gt; selectByExample(Object example) &#123; return baseMapper.selectByExample(example); &#125; @Override public int selectCountByExample(Object example) &#123; return baseMapper.selectCountByExample(example); &#125; @Override public int updateByExample(T record, Object example) &#123; return baseMapper.updateByExample(record,example); &#125; @Override public int updateByExampleSelective(T record, Object example) &#123; return baseMapper.updateByExampleSelective(record,example); &#125; @Override public int deleteByExample(Object example) &#123; return baseMapper.deleteByExample(example); &#125; @Override public int insert(T record) &#123; return baseMapper.insert(record); &#125; @Override public int insertSelective(T record) &#123; return baseMapper.insertSelective(record); &#125; @Override public int insertListSelective(List&lt;T&gt; recordList) &#123; for (T record : recordList) &#123; baseMapper.insertSelective(record); &#125; return 1; &#125; @Override public int updateByPrimaryKey(T record) &#123; return baseMapper.updateByPrimaryKey(record); &#125; @Override public int updateByPrimaryKeySelective(T record) &#123; return baseMapper.updateByPrimaryKeySelective(record); &#125; @Override public int delete(T record) &#123; return baseMapper.delete(record); &#125; @Override public int deleteByPrimaryKey(Object key) &#123; return baseMapper.deleteByPrimaryKey(key); &#125;&#125; 业务Service实现将通用mapper中一些常用的方法进行实现，业务Service此处就省略（需要继承公共Service接口）具体业务类的Service可实现如下： 1234567891011package com.sjiay.demo.service.wszy.impl;import com.sjiay.demo.entity.user;import com.sjiay.demo.service.base.impl.BaseServiceImpl;import com.sjiay.demo.service.wszy.UserService;import org.springframework.stereotype.Service;@Servicepublic class UserServiceImpl extends BaseServiceImpl&lt;user&gt; implements UserService &#123;&#125; 在只有通用方法时就不需要加任何方法，是不是显得特别简约方便。 八、测试一下12345678910111213141516171819202122232425262728293031323334353637package com.sjiay.demo.controller;import com.dongfang.mhh.mhhbase.ResMsg;import com.dongfang.mhh.mhhbase.ResMsgpage;import com.github.pagehelper.PageHelper;import com.github.pagehelper.PageInfo;import com.sjiay.demo.service.wszy.UserService;import com.sjiay.demo.entity.XzyyFuwujg;import org.apache.commons.lang.StringUtils;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.web.bind.annotation.*;import tk.mybatis.mapper.entity.Example;import java.util.List;@RestController@RequestMapping(&quot;/demo&quot;)public class UserController &#123; @Autowired private UserService userService; /** * 获取用户列表 */ @PostMapping(&quot;/getUserList&quot;) public ResMsgpage getJgxxList(@RequestBody User user) &#123; Example example = new Example(User.class); Example.Criteria criteria = example.createCriteria(); criteria.andBetween(&quot;chushengrq&quot;,user.getRiqi1(),user.getRiqi2()); example.and(criteria); PageHelper.startPage(user.getPage(), user.getRows(), true); List&lt;User&gt; userList = userService.selectByExample(example); PageInfo&lt;User&gt; pageInfo=new PageInfo&lt;User&gt;(userList); Long page = Long.valueOf(user.getPage()); Long total = Long.valueOf(pageInfo.getPages()); return new ResMsgpage(userList,page,pageInfo.getTotal(),total); &#125; 实际项目中上面的返回结果集都做过封装，简单使用可直接通过List来返回，上述过程都是亲测成功，如有需要用到通用mapper的欢迎参考。上述内容纯属个人总结，如有错误欢迎拍砖！","categories":[{"name":"后端","slug":"后端","permalink":"https://Sjiay1023.github.io/categories/后端/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"https://Sjiay1023.github.io/tags/Spring/"}]},{"title":"第一个博客","slug":"me-first-blog","date":"2019-08-19T10:25:11.000Z","updated":"2019-08-20T09:13:33.536Z","comments":true,"path":"2019/08/19/me-first-blog/","link":"","permalink":"https://Sjiay1023.github.io/2019/08/19/me-first-blog/","excerpt":"欢迎使用Markdown编辑器写博客 //一级标题 对应 标题输入 //二级标题 对应 三级标题 //三级标题 对应 四级标题 //四级标题 对应 五级标题 //五级标题 对应 六级标题 //六级标题 对应 ####### 七级标题 //抱歉，木有了（但是他会影响生成的目录，目录行多出一行空行）","text":"欢迎使用Markdown编辑器写博客 //一级标题 对应 标题输入 //二级标题 对应 三级标题 //三级标题 对应 四级标题 //四级标题 对应 五级标题 //五级标题 对应 六级标题 //六级标题 对应 ####### 七级标题 //抱歉，木有了（但是他会影响生成的目录，目录行多出一行空行） 123#!/usr/bin/env python# -*- coding: utf-8 -*-print 'Hello World! 列1 列2 列3 第1行 12 13 第2行 22 23 第3行 32 33 斜体， 粗体","categories":[{"name":"个人","slug":"个人","permalink":"https://Sjiay1023.github.io/categories/个人/"}],"tags":[{"name":"个人","slug":"个人","permalink":"https://Sjiay1023.github.io/tags/个人/"}]},{"title":"Hello World","slug":"hello-world","date":"2019-08-19T08:37:14.431Z","updated":"2019-08-20T05:59:59.775Z","comments":true,"path":"2019/08/19/hello-world/","link":"","permalink":"https://Sjiay1023.github.io/2019/08/19/hello-world/","excerpt":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}